record Projectile {
	Transform start
	Float32 length
	Boolean player
}

record Menu {
	ItemPicker items
}

enum Ui {
	Nothing
	Menu
}

record MaybeVehicle {
	game.Vehicle vehicle
	Boolean is_alive
}

enum EnemyIndex {
	A
	B
	C
}

enum game.ProjectileIndex {
	R
	S
	T
	U
}

register game.Gltf map

register MaybeVehicle player
register [EnemyIndex -> MaybeVehicle] enemies

register [game.ProjectileIndex -> Projectile] projectiles

register game.Mesh projectile_mesh
register game.Material projectile_material_player
register game.Material projectile_material_enemy

register Boolean exit

function start() {
	map = game.graphics.load_gltf("map.gltf")

	player = load_vehicle("args:player.vvt")
	enemies[A] = load_vehicle("data:a.vvt")
	enemies[B] = load_vehicle("data:b.vvt")
	enemies[C] = load_vehicle("data:c.vvt")

	for ref projectile in projectiles {
		projectile.start = transform.zero()
		projectile.length = 0
	}

	loop {
		step()
		draw()
		if exit {
			break
		}
	}
}

function load_vehicle(ConstantString path) -> MaybeVehicle {
	MaybeVehicle v
	v.vehicle = game.vehicle.load_v0(path)
	v.is_alive = true
	return v
}

function step() {
	game.wait_step()

	game.physics.step()

	if player.is_alive {
		game.vehicle.step(ref player.vehicle)
	}

	for ref v in enemies {
		if v.is_alive {
			game.vehicle.step(ref v.vehicle)
		}
	}
}

function draw() {
	game.wait_draw()

	game.graphics.draw(map)

	if player.is_alive {
		game.vehicle.draw(player.vehicle)
	}

	for ref v in enemies {
		if v.is_alive {
			game.vehicle.draw(ref v.vehicle)
		}
	}

	for p in projectiles {
		if float32.eq(p.length, 0) {
			break
		}
		Projectile.draw(p)
	}
}

function Projectile.draw(Projectile projectile) {
}
